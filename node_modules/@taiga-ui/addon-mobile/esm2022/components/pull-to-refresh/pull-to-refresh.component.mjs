import { AsyncPipe } from '@angular/common';
import { ChangeDetectionStrategy, Component, inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { tuiScrollFrom, tuiZonefree } from '@taiga-ui/cdk/observables';
import { TUI_IS_IOS } from '@taiga-ui/cdk/tokens';
import { tuiPx } from '@taiga-ui/cdk/utils/miscellaneous';
import { TUI_SCROLL_REF } from '@taiga-ui/core/tokens';
import { PolymorpheusOutlet } from '@taiga-ui/polymorpheus';
import { distinctUntilChanged, filter, map, startWith } from 'rxjs';
import { TUI_PULL_TO_REFRESH_COMPONENT, TUI_PULL_TO_REFRESH_THRESHOLD, } from './pull-to-refresh.providers';
import { MICRO_OFFSET, TuiPullToRefreshService } from './pull-to-refresh.service';
import * as i0 from "@angular/core";
class TuiPullToRefresh {
    constructor() {
        this.isIOS = inject(TUI_IS_IOS);
        this.threshold = inject(TUI_PULL_TO_REFRESH_THRESHOLD);
        this.pulling$ = inject(TuiPullToRefreshService);
        this.component = inject(TUI_PULL_TO_REFRESH_COMPONENT);
        this.dropped$ = this.pulling$.pipe(map((distance) => distance <= MICRO_OFFSET || distance === this.threshold), distinctUntilChanged());
        this.styleHandler = this.isIOS
            ? (distance) => ({ top: tuiPx(distance / 2) })
            : () => null;
        this.pulled = inject(TuiPullToRefreshService).pipe(filter((distance) => distance === this.threshold));
        if (!this.component) {
            return; // Ensure scrolling down is impossible while pulling
        }
        const el = inject(TUI_SCROLL_REF).nativeElement;
        tuiScrollFrom(el)
            .pipe(startWith(null), tuiZonefree(), takeUntilDestroyed())
            .subscribe(() => {
            if (el.scrollTop) {
                el.style.touchAction = '';
            }
            else {
                el.style.touchAction = 'pan-down';
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiPullToRefresh, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TuiPullToRefresh, isStandalone: true, selector: "tui-pull-to-refresh", inputs: { styleHandler: "styleHandler" }, outputs: { pulled: "pulled" }, providers: [TuiPullToRefreshService], ngImport: i0, template: "<ng-container *polymorpheusOutlet=\"component; context: {$implicit: (pulling$ | async) || 0}\" />\n\n<div\n    [class.t-drop]=\"dropped$ | async\"\n    [style.position]=\"'relative'\"\n    [style]=\"styleHandler((pulling$ | async) || 0)\"\n>\n    <ng-content />\n</div>\n", styles: [".t-drop{transition:all var(--tui-duration) cubic-bezier(.4,0,.2,1)}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "directive", type: PolymorpheusOutlet, selector: "[polymorpheusOutlet]", inputs: ["polymorpheusOutlet", "polymorpheusOutletContext"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { TuiPullToRefresh };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiPullToRefresh, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'tui-pull-to-refresh', imports: [AsyncPipe, PolymorpheusOutlet], changeDetection: ChangeDetectionStrategy.OnPush, providers: [TuiPullToRefreshService], template: "<ng-container *polymorpheusOutlet=\"component; context: {$implicit: (pulling$ | async) || 0}\" />\n\n<div\n    [class.t-drop]=\"dropped$ | async\"\n    [style.position]=\"'relative'\"\n    [style]=\"styleHandler((pulling$ | async) || 0)\"\n>\n    <ng-content />\n</div>\n", styles: [".t-drop{transition:all var(--tui-duration) cubic-bezier(.4,0,.2,1)}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { styleHandler: [{
                type: Input
            }], pulled: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbC10by1yZWZyZXNoLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FkZG9uLW1vYmlsZS9jb21wb25lbnRzL3B1bGwtdG8tcmVmcmVzaC9wdWxsLXRvLXJlZnJlc2guY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYWRkb24tbW9iaWxlL2NvbXBvbmVudHMvcHVsbC10by1yZWZyZXNoL3B1bGwtdG8tcmVmcmVzaC50ZW1wbGF0ZS5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUMxQyxPQUFPLEVBQUMsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3hGLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQzlELE9BQU8sRUFBQyxhQUFhLEVBQUUsV0FBVyxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDckUsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRWhELE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RCxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFckQsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFFMUQsT0FBTyxFQUFDLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBRWxFLE9BQU8sRUFDSCw2QkFBNkIsRUFDN0IsNkJBQTZCLEdBQ2hDLE1BQU0sNkJBQTZCLENBQUM7QUFDckMsT0FBTyxFQUFDLFlBQVksRUFBRSx1QkFBdUIsRUFBQyxNQUFNLDJCQUEyQixDQUFDOztBQUVoRixNQVNhLGdCQUFnQjtJQXdCekI7UUF2QmlCLFVBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDM0IsY0FBUyxHQUFHLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBRWhELGFBQVEsR0FBRyxNQUFNLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUMzQyxjQUFTLEdBQUcsTUFBTSxDQUNqQyw2QkFBNkIsQ0FDaEMsQ0FBQztRQUVpQixhQUFRLEdBQXdCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUNqRSxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsSUFBSSxZQUFZLElBQUksUUFBUSxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsRUFDMUUsb0JBQW9CLEVBQUUsQ0FDekIsQ0FBQztRQUdLLGlCQUFZLEdBQXVELElBQUksQ0FBQyxLQUFLO1lBQ2hGLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxFQUFDLENBQUM7WUFDNUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQztRQUdELFdBQU0sR0FBd0IsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUMsSUFBSSxDQUM5RSxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQ3BELENBQUM7UUFHRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNqQixPQUFPLENBQUMsb0RBQW9EO1NBQy9EO1FBRUQsTUFBTSxFQUFFLEdBQWdCLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxhQUFhLENBQUM7UUFFN0QsYUFBYSxDQUFDLEVBQUUsQ0FBQzthQUNaLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQzthQUMxRCxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ1osSUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFO2dCQUNkLEVBQUUsQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQzthQUM3QjtpQkFBTTtnQkFDSCxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUM7YUFDckM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7K0dBeENRLGdCQUFnQjttR0FBaEIsZ0JBQWdCLDJJQUZkLENBQUMsdUJBQXVCLENBQUMsMEJDMUJ4QyxpUkFTQSwwSERhYyxTQUFTLDhDQUFFLGtCQUFrQjs7U0FNOUIsZ0JBQWdCOzRGQUFoQixnQkFBZ0I7a0JBVDVCLFNBQVM7aUNBQ00sSUFBSSxZQUNOLHFCQUFxQixXQUN0QixDQUFDLFNBQVMsRUFBRSxrQkFBa0IsQ0FBQyxtQkFHdkIsdUJBQXVCLENBQUMsTUFBTSxhQUNwQyxDQUFDLHVCQUF1QixDQUFDOzBFQWlCN0IsWUFBWTtzQkFEbEIsS0FBSztnQkFNVSxNQUFNO3NCQURyQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtBc3luY1BpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0NoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIGluamVjdCwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge3Rha2VVbnRpbERlc3Ryb3llZH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuaW1wb3J0IHt0dWlTY3JvbGxGcm9tLCB0dWlab25lZnJlZX0gZnJvbSAnQHRhaWdhLXVpL2Nkay9vYnNlcnZhYmxlcyc7XG5pbXBvcnQge1RVSV9JU19JT1N9IGZyb20gJ0B0YWlnYS11aS9jZGsvdG9rZW5zJztcbmltcG9ydCB0eXBlIHtUdWlDb250ZXh0LCBUdWlIYW5kbGVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3R5cGVzJztcbmltcG9ydCB7dHVpUHh9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQge1RVSV9TQ1JPTExfUkVGfSBmcm9tICdAdGFpZ2EtdWkvY29yZS90b2tlbnMnO1xuaW1wb3J0IHR5cGUge1BvbHltb3JwaGV1c0NvbnRlbnR9IGZyb20gJ0B0YWlnYS11aS9wb2x5bW9ycGhldXMnO1xuaW1wb3J0IHtQb2x5bW9ycGhldXNPdXRsZXR9IGZyb20gJ0B0YWlnYS11aS9wb2x5bW9ycGhldXMnO1xuaW1wb3J0IHR5cGUge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAsIHN0YXJ0V2l0aH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7XG4gICAgVFVJX1BVTExfVE9fUkVGUkVTSF9DT01QT05FTlQsXG4gICAgVFVJX1BVTExfVE9fUkVGUkVTSF9USFJFU0hPTEQsXG59IGZyb20gJy4vcHVsbC10by1yZWZyZXNoLnByb3ZpZGVycyc7XG5pbXBvcnQge01JQ1JPX09GRlNFVCwgVHVpUHVsbFRvUmVmcmVzaFNlcnZpY2V9IGZyb20gJy4vcHVsbC10by1yZWZyZXNoLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIHNlbGVjdG9yOiAndHVpLXB1bGwtdG8tcmVmcmVzaCcsXG4gICAgaW1wb3J0czogW0FzeW5jUGlwZSwgUG9seW1vcnBoZXVzT3V0bGV0XSxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcHVsbC10by1yZWZyZXNoLnRlbXBsYXRlLmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3B1bGwtdG8tcmVmcmVzaC5zdHlsZS5sZXNzJ10sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbVHVpUHVsbFRvUmVmcmVzaFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBUdWlQdWxsVG9SZWZyZXNoIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlzSU9TID0gaW5qZWN0KFRVSV9JU19JT1MpO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdGhyZXNob2xkID0gaW5qZWN0KFRVSV9QVUxMX1RPX1JFRlJFU0hfVEhSRVNIT0xEKTtcblxuICAgIHByb3RlY3RlZCByZWFkb25seSBwdWxsaW5nJCA9IGluamVjdChUdWlQdWxsVG9SZWZyZXNoU2VydmljZSk7XG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbXBvbmVudCA9IGluamVjdDxQb2x5bW9ycGhldXNDb250ZW50PFR1aUNvbnRleHQ8bnVtYmVyPj4+KFxuICAgICAgICBUVUlfUFVMTF9UT19SRUZSRVNIX0NPTVBPTkVOVCxcbiAgICApO1xuXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGRyb3BwZWQkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5wdWxsaW5nJC5waXBlKFxuICAgICAgICBtYXAoKGRpc3RhbmNlKSA9PiBkaXN0YW5jZSA8PSBNSUNST19PRkZTRVQgfHwgZGlzdGFuY2UgPT09IHRoaXMudGhyZXNob2xkKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICApO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3R5bGVIYW5kbGVyOiBUdWlIYW5kbGVyPG51bWJlciwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsPiA9IHRoaXMuaXNJT1NcbiAgICAgICAgPyAoZGlzdGFuY2UpID0+ICh7dG9wOiB0dWlQeChkaXN0YW5jZSAvIDIpfSlcbiAgICAgICAgOiAoKSA9PiBudWxsO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHB1bGxlZDogT2JzZXJ2YWJsZTx1bmtub3duPiA9IGluamVjdChUdWlQdWxsVG9SZWZyZXNoU2VydmljZSkucGlwZShcbiAgICAgICAgZmlsdGVyKChkaXN0YW5jZSkgPT4gZGlzdGFuY2UgPT09IHRoaXMudGhyZXNob2xkKSxcbiAgICApO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRW5zdXJlIHNjcm9sbGluZyBkb3duIGlzIGltcG9zc2libGUgd2hpbGUgcHVsbGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWw6IEhUTUxFbGVtZW50ID0gaW5qZWN0KFRVSV9TQ1JPTExfUkVGKS5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgIHR1aVNjcm9sbEZyb20oZWwpXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgobnVsbCksIHR1aVpvbmVmcmVlKCksIHRha2VVbnRpbERlc3Ryb3llZCgpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS50b3VjaEFjdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRvdWNoQWN0aW9uID0gJ3Bhbi1kb3duJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4iLCI8bmctY29udGFpbmVyICpwb2x5bW9ycGhldXNPdXRsZXQ9XCJjb21wb25lbnQ7IGNvbnRleHQ6IHskaW1wbGljaXQ6IChwdWxsaW5nJCB8IGFzeW5jKSB8fCAwfVwiIC8+XG5cbjxkaXZcbiAgICBbY2xhc3MudC1kcm9wXT1cImRyb3BwZWQkIHwgYXN5bmNcIlxuICAgIFtzdHlsZS5wb3NpdGlvbl09XCIncmVsYXRpdmUnXCJcbiAgICBbc3R5bGVdPVwic3R5bGVIYW5kbGVyKChwdWxsaW5nJCB8IGFzeW5jKSB8fCAwKVwiXG4+XG4gICAgPG5nLWNvbnRlbnQgLz5cbjwvZGl2PlxuIl19